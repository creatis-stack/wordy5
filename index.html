<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wordy</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
        }
        .word-fade-in {
            animation: fadeIn 0.5s ease-in;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .example-highlight {
            background: linear-gradient(120deg, rgba(255, 255, 0, 0.3) 0%, rgba(255, 255, 0, 0.1) 100%);
            padding: 0 4px;
            border-radius: 3px;
        }
        .review-indicator {
            background: linear-gradient(45deg, #ffd700, #ffed4e);
            color: #1a202c;
            font-weight: bold;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useEffect } = React;

        // Enhanced SVG icons
        const ChevronLeft = () => (
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <polyline points="15,18 9,12 15,6"></polyline>
            </svg>
        );

        const ChevronRight = () => (
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <polyline points="9,18 15,12 9,6"></polyline>
            </svg>
        );

        const Volume2 = ({ size = 20 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <polygon points="11,5 6,9 2,9 2,15 6,15 11,19"></polygon>
                <path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path>
            </svg>
        );

        const Clock = ({ size = 16 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <circle cx="12" cy="12" r="10"></circle>
                <polyline points="12,6 12,12 16,14"></polyline>
            </svg>
        );

        const BookOpen = ({ size = 16 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path>
                <path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path>
            </svg>
        );

        const Star = ({ size = 16, filled = false }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill={filled ? "currentColor" : "none"} stroke="currentColor" strokeWidth="2">
                <polygon points="12,2 15.09,8.26 22,9.27 17,14.14 18.18,21.02 12,17.77 5.82,21.02 7,14.14 2,9.27 8.91,8.26"></polygon>
            </svg>
        );

        const RefreshCw = ({ size = 16 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <polyline points="23,4 23,10 17,10"></polyline>
                <polyline points="1,20 1,14 7,14"></polyline>
                <path d="M20.49 9A9 9 0 0 0 5.64 5.64L1 10m22 4l-4.64 4.36A9 9 0 0 1 3.51 15"></path>
            </svg>
        );

        const VocabularyBuilder = () => {
            const [currentWeek, setCurrentWeek] = useState(0);
            const [currentExample, setCurrentExample] = useState(0);
            const [timeUntilMidnight, setTimeUntilMidnight] = useState('');
            const [vocabularyDatabase, setVocabularyDatabase] = useState([]);
            const [isLoading, setIsLoading] = useState(true);
            const [loadError, setLoadError] = useState(null);
            
            // Load favorite words with review tracking
            const [favoriteWords, setFavoriteWords] = useState(() => {
                const saved = localStorage.getItem('favoriteWords');
                return saved ? JSON.parse(saved) : [];
            });

            // Load favorite review schedule
            const [favoriteReviews, setFavoriteReviews] = useState(() => {
                const saved = localStorage.getItem('favoriteReviews');
                return saved ? JSON.parse(saved) : {};
            });
            
            // Helper function to get midnight of a date
            const getMidnight = (date) => {
                const midnight = new Date(date);
                midnight.setHours(0, 0, 0, 0);
                return midnight;
            };

            // Helper function to get days between two dates (midnight to midnight)
            const getDaysBetween = (startDate, endDate) => {
                const start = getMidnight(startDate);
                const end = getMidnight(endDate);
                const timeDiff = end.getTime() - start.getTime();
                return Math.floor(timeDiff / (1000 * 60 * 60 * 24));
            };

            // Initialize or get start date (always at midnight)
            const [startDate] = useState(() => {
                const saved = localStorage.getItem('vocabStartDate');
                if (saved) {
                    return getMidnight(new Date(saved));
                } else {
                    const today = getMidnight(new Date());
                    localStorage.setItem('vocabStartDate', today.toISOString());
                    return today;
                }
            });

            // Load vocabulary from JSON file
            useEffect(() => {
                const loadVocabulary = async () => {
                    try {
                        const response = await fetch('./vocabulary.json');
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        const data = await response.json();
                        setVocabularyDatabase(data);
                        setIsLoading(false);
                    } catch (error) {
                        console.error('Failed to load vocabulary:', error);
                        setLoadError(error.message);
                        setIsLoading(false);
                        // Fallback to a minimal vocabulary set
                        setVocabularyDatabase([
                            {
                                word: "resilient",
                                pronunciation: "/rɪˈzɪljənt/",
                                partOfSpeech: "adjective",
                                meaning: "able to recover quickly from difficulties; strong and flexible",
                                difficulty: 0,
                                etymology: "From Latin 'resilire' meaning 'to rebound'",
                                examples: [
                                    "The resilient community rebuilt after challenges.",
                                    "Her resilient nature helped her adapt to change.",
                                    "Through resilient effort, they preserved their traditions.",
                                    "The resilient spirit of the family endured.",
                                    "His resilient optimism inspired others.",
                                    "The resilient bond between them grew stronger.",
                                    "Their resilient approach solved the problem."
                                ]
                            }
                        ]);
                    }
                };
                
                loadVocabulary();
            }, []);

            // Calculate time until next midnight
            const calculateTimeUntilMidnight = () => {
                const now = new Date();
                const tomorrow = new Date(now);
                tomorrow.setDate(tomorrow.getDate() + 1);
                tomorrow.setHours(0, 0, 0, 0);
                
                const timeDiff = tomorrow.getTime() - now.getTime();
                const hours = Math.floor(timeDiff / (1000 * 60 * 60));
                const minutes = Math.floor((timeDiff % (1000 * 60 * 60)) / (1000 * 60));
                const seconds = Math.floor((timeDiff % (1000 * 60)) / 1000);
                
                return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            };

            // Load skipped words from localStorage  
            const [skippedWords, setSkippedWords] = useState(() => {
                const saved = localStorage.getItem('vocabSkippedWords');
                return saved ? JSON.parse(saved) : [];
            });

            // Calculate current week and day based on midnight boundaries
            useEffect(() => {
                if (vocabularyDatabase.length === 0) return; // Don't run until vocabulary is loaded
                const updateProgress = () => {
                    const now = new Date();
                    const daysPassed = getDaysBetween(startDate, now);
                    
                    // Fixed calculation: week starts at 0, not affected by skipped words for display
                    const calculatedWeek = Math.floor(daysPassed / 7);
                    const calculatedExample = daysPassed % 7;
                    
                    setCurrentWeek(calculatedWeek);
                    setCurrentExample(calculatedExample);
                    setTimeUntilMidnight(calculateTimeUntilMidnight());
                };

                // Update immediately
                updateProgress();

                // Update every second for the countdown
                const interval = setInterval(updateProgress, 1000);

                return () => clearInterval(interval);
            }, [startDate, vocabularyDatabase.length]);

            // Check if it's time to review a favorite word
            const checkForReview = () => {
                const today = new Date().toDateString();
                for (const [word, reviewDate] of Object.entries(favoriteReviews)) {
                    if (new Date(reviewDate).toDateString() === today && favoriteWords.includes(word)) {
                        const wordData = vocabularyDatabase.find(w => w.word === word);
                        if (wordData) {
                            return wordData; // Return the word to review
                        }
                    }
                }
                return null;
            };

            // Get word based on review schedule or sequential progression
            const getWeeklyWord = (weekIndex) => {
                if (vocabularyDatabase.length === 0) {
                    return { word: "loading", meaning: "Please wait...", examples: [""], difficulty: 0 };
                }

                // First check if there's a word to review today
                const reviewWord = checkForReview();
                if (reviewWord) {
                    return { ...reviewWord, isReview: true };
                }

                // Get regular word progression - use total progress for sequential learning
                const totalWordsProgressed = weekIndex + skippedWords.length;
                
                // Simply cycle through all words sequentially
                return vocabularyDatabase[totalWordsProgressed % vocabularyDatabase.length];
            };

            const currentWord = getWeeklyWord(currentWeek);

            // Toggle favorite word with spaced repetition scheduling
            const toggleFavorite = (word) => {
                const newFavorites = favoriteWords.includes(word) 
                    ? favoriteWords.filter(w => w !== word)
                    : [...favoriteWords, word];
                
                setFavoriteWords(newFavorites);
                localStorage.setItem('favoriteWords', JSON.stringify(newFavorites));

                // Schedule review for newly favorited words (4-6 weeks from now)
                if (!favoriteWords.includes(word)) {
                    const reviewInterval = 4 + Math.floor(Math.random() * 3); // 4-6 weeks
                    const reviewDate = new Date();
                    reviewDate.setDate(reviewDate.getDate() + (reviewInterval * 7));
                    
                    const newReviews = {
                        ...favoriteReviews,
                        [word]: reviewDate.toISOString()
                    };
                    setFavoriteReviews(newReviews);
                    localStorage.setItem('favoriteReviews', JSON.stringify(newReviews));
                } else {
                    // Remove from review schedule if unfavorited
                    const newReviews = { ...favoriteReviews };
                    delete newReviews[word];
                    setFavoriteReviews(newReviews);
                    localStorage.setItem('favoriteReviews', JSON.stringify(newReviews));
                }
            };

            // Mark review as completed and reschedule
            const completeReview = (word) => {
                const reviewInterval = 4 + Math.floor(Math.random() * 3); // 4-6 weeks
                const nextReviewDate = new Date();
                nextReviewDate.setDate(nextReviewDate.getDate() + (reviewInterval * 7));
                
                const newReviews = {
                    ...favoriteReviews,
                    [word]: nextReviewDate.toISOString()
                };
                setFavoriteReviews(newReviews);
                localStorage.setItem('favoriteReviews', JSON.stringify(newReviews));
            };

            // Skip current word function
            const skipCurrentWord = () => {
                if (currentWord.isReview) {
                    // If it's a review word, just reschedule it
                    completeReview(currentWord.word);
                } else {
                    // If it's a regular word, add to skipped list
                    const newSkippedWords = [...skippedWords, currentWord.word];
                    setSkippedWords(newSkippedWords);
                    localStorage.setItem('vocabSkippedWords', JSON.stringify(newSkippedWords));
                }
                
                // Force update by incrementing week temporarily
                setCurrentWeek(currentWeek + 1);
                setTimeout(() => {
                    // Then reset to actual current week
                    const now = new Date();
                    const daysPassed = getDaysBetween(startDate, now);
                    setCurrentWeek(Math.floor(daysPassed / 7));
                    setCurrentExample(daysPassed % 7);
                }, 100);
            };

            // Highlight the current word in examples
            const highlightWordInExample = (example, word) => {
                const regex = new RegExp(`\\b${word}\\b`, 'gi');
                return example.replace(regex, `<span class="example-highlight">${word}</span>`);
            };

            // Audio pronunciation
            const speakWord = (text) => {
                if ('speechSynthesis' in window) {
                    speechSynthesis.cancel();
                    
                    const utterance = new SpeechSynthesisUtterance(text);
                    utterance.rate = 0.7;
                    utterance.pitch = 1.0;
                    utterance.volume = 1.0;
                    
                    const voices = speechSynthesis.getVoices();
                    const englishVoice = voices.find(voice => 
                        voice.lang.startsWith('en') && voice.name.includes('Enhanced')
                    ) || voices.find(voice => voice.lang.startsWith('en'));
                    
                    if (englishVoice) {
                        utterance.voice = englishVoice;
                    }
                    
                    speechSynthesis.speak(utterance);
                } else {
                    alert('Speech synthesis not supported in this browser');
                }
            };

            // Get difficulty label
            const getDifficultyLabel = (difficulty) => {
                const labels = {
                    '-2': 'Beginner',
                    '-1': 'Elementary',
                    '0': 'Intermediate',
                    '1': 'Advanced',
                    '2': 'Expert'
                };
                return labels[difficulty] || 'Intermediate';
            };

            // Calculate total stats
            const totalWordsLearned = currentWeek + 1;
            const totalWordsSkipped = skippedWords.length;
            const totalProgress = totalWordsLearned + totalWordsSkipped;

            // Show loading or error state
            if (isLoading) {
                return React.createElement('div', {
                    className: "min-h-screen bg-gradient-to-br from-blue-900 via-purple-900 to-indigo-900 text-white p-6 flex items-center justify-center"
                },
                    React.createElement('div', { className: "text-center" },
                        React.createElement('h1', { className: "text-4xl font-bold mb-4" }, "Wordy"),
                        React.createElement('p', { className: "text-xl" }, "Loading vocabulary...")
                    )
                );
            }

            if (loadError) {
                return React.createElement('div', {
                    className: "min-h-screen bg-gradient-to-br from-blue-900 via-purple-900 to-indigo-900 text-white p-6 flex items-center justify-center"
                },
                    React.createElement('div', { className: "text-center" },
                        React.createElement('h1', { className: "text-4xl font-bold mb-4" }, "Wordy"),
                        React.createElement('p', { className: "text-xl text-red-300 mb-4" }, `Error loading vocabulary: ${loadError}`),
                        React.createElement('p', { className: "text-lg" }, "Using fallback vocabulary. Please ensure vocabulary.json is in the same directory as this file.")
                    )
                );
            }

            return React.createElement('div', {
                className: "min-h-screen bg-gradient-to-br from-blue-900 via-purple-900 to-indigo-900 text-white p-6"
            }, 
                React.createElement('div', { className: "max-w-4xl mx-auto" },
                    // Header
                    React.createElement('div', { className: "text-center mb-8" },
                        React.createElement('h1', { className: "text-4xl font-bold mb-2" }, "Wordy"),
                        React.createElement('p', { className: "text-blue-200 mb-2" }, 
                            `Week ${currentWeek + 1} • ${getDifficultyLabel(currentWord.difficulty)} Level${currentWord.isReview ? ' • 🔄 Review' : ''}`
                        ),
                        React.createElement('div', { className: "flex items-center justify-center gap-2 text-sm text-yellow-300" },
                            React.createElement(Clock, { size: 16 }),
                            React.createElement('span', null, `Next update in: ${timeUntilMidnight}`)
                        )
                    ),

                    // Review notification
                    currentWord.isReview && React.createElement('div', { 
                        className: "review-indicator rounded-xl p-4 mb-6 text-center"
                    },
                        React.createElement('div', { className: "flex items-center justify-center gap-2 mb-2" },
                            React.createElement(RefreshCw, { size: 20 }),
                            React.createElement('span', { className: "font-bold text-lg" }, "Time to Review!")
                        ),
                        React.createElement('p', { className: "text-sm" }, 
                            `You starred "${currentWord.word}" and it's ready for spaced repetition review.`
                        )
                    ),

                    // Main Word Card
                    React.createElement('div', { className: "bg-white/10 backdrop-blur-lg rounded-2xl p-8 mb-6 border border-white/20 word-fade-in" },
                        React.createElement('div', { className: "text-center mb-6" },
                            React.createElement('div', { className: "flex items-center justify-center gap-4 mb-4" },
                                React.createElement('h2', { className: "text-5xl font-bold text-yellow-300" }, currentWord.word),
                                React.createElement('button', {
                                    onClick: () => toggleFavorite(currentWord.word),
                                    className: `p-2 rounded-full transition-colors ${favoriteWords.includes(currentWord.word) ? 'text-yellow-300 bg-yellow-300/20' : 'text-gray-400 hover:text-yellow-300'}`
                                }, React.createElement(Star, { size: 24, filled: favoriteWords.includes(currentWord.word) }))
                            ),
                            React.createElement('div', { className: "flex items-center justify-center gap-4 mb-4" },
                                React.createElement('span', { className: "text-xl text-blue-200 font-mono" }, currentWord.pronunciation),
                                React.createElement('button', {
                                    onClick: () => speakWord(currentWord.word),
                                    className: "p-2 bg-blue-600 hover:bg-blue-700 rounded-full transition-colors hover:scale-105 active:scale-95",
                                    title: "Listen to pronunciation"
                                }, React.createElement(Volume2, { size: 20 }))
                            ),
                            React.createElement('p', { className: "text-lg text-purple-200 italic mb-2" }, currentWord.partOfSpeech),
                            React.createElement('p', { className: "text-xl leading-relaxed mb-3" }, currentWord.meaning),
                            React.createElement('p', { className: "text-sm text-gray-300 italic" }, `Etymology: ${currentWord.etymology}`)
                        )
                    ),

                    // Daily Example
                    React.createElement('div', { className: "bg-white/10 backdrop-blur-lg rounded-2xl p-6 mb-6 border border-white/20" },
                        React.createElement('div', { className: "flex items-center justify-between mb-4" },
                            React.createElement('h3', { className: "text-2xl font-semibold flex items-center gap-2" }, 
                                React.createElement(BookOpen, { size: 20 }),
                                currentWord.isReview ? "Review Example" : "Today's Contextual Usage"
                            ),
                            !currentWord.isReview && React.createElement('span', { className: "text-sm text-blue-200" }, `Day ${currentExample + 1} of 7`)
                        ),
                        React.createElement('div', { 
                            className: "text-lg leading-relaxed text-yellow-200 border-l-4 border-yellow-400 pl-6 italic",
                            dangerouslySetInnerHTML: { 
                                __html: highlightWordInExample(
                                    currentWord.examples[currentWord.isReview ? 0 : currentExample], 
                                    currentWord.word
                                ) 
                            }
                        }),
                        currentWord.isReview && React.createElement('div', { className: "mt-4 text-center" },
                            React.createElement('button', {
                                onClick: () => {
                                    completeReview(currentWord.word);
                                    // Force refresh to show next word
                                    setCurrentWeek(currentWeek + 1);
                                    setTimeout(() => {
                                        const now = new Date();
                                        const daysPassed = getDaysBetween(startDate, now);
                                        setCurrentWeek(Math.floor(daysPassed / 7));
                                        setCurrentExample(daysPassed % 7);
                                    }, 100);
                                },
                                className: "px-6 py-2 bg-green-600 hover:bg-green-700 rounded-lg transition-colors font-semibold"
                            }, "Mark as Reviewed ✓")
                        )
                    ),

                    // Controls - Now with 2 columns instead of 3
                    React.createElement('div', { className: "grid grid-cols-1 md:grid-cols-2 gap-4 mb-6" },
                        // Week Navigation
                        React.createElement('div', { className: "bg-white/10 backdrop-blur-lg rounded-xl p-4 border border-white/20" },
                            React.createElement('h4', { className: "font-semibold mb-3" }, "Navigation"),
                            React.createElement('div', { className: "flex flex-col gap-2" },
                                React.createElement('button', {
                                    onClick: () => setCurrentWeek(Math.max(0, currentWeek - 1)),
                                    disabled: currentWeek === 0,
                                    className: "px-4 py-2 bg-indigo-600 hover:bg-indigo-700 disabled:bg-gray-600 disabled:cursor-not-allowed rounded-lg transition-colors flex items-center justify-center gap-2"
                                }, React.createElement(ChevronLeft), "Previous Week"),
                                React.createElement('button', {
                                    onClick: skipCurrentWord,
                                    className: "px-4 py-2 bg-orange-600 hover:bg-orange-700 rounded-lg transition-colors flex items-center justify-center gap-2"
                                }, React.createElement(ChevronRight), currentWord.isReview ? "Skip Review" : "Skip Word")
                            ),
                            React.createElement('p', { className: "text-xs text-blue-200 mt-2" }, 
                                currentWord.isReview ? "Reviews appear when ready" : "Auto-updates at midnight"
                            )
                        ),

                        // Learning Stats
                        React.createElement('div', { className: "bg-white/10 backdrop-blur-lg rounded-xl p-4 border border-white/20" },
                            React.createElement('h4', { className: "font-semibold mb-3" }, "Learning Stats"),
                            React.createElement('div', { className: "text-sm space-y-1" },
                                React.createElement('p', null, `Words learned: ${totalWordsLearned}`),
                                React.createElement('p', null, `Words skipped: ${totalWordsSkipped}`),
                                React.createElement('p', null, `Favorite words: ${favoriteWords.length}`),
                                React.createElement('p', null, `Reviews scheduled: ${Object.keys(favoriteReviews).length}`),
                                React.createElement('p', { className: "text-green-400 font-semibold" }, `Total progress: ${totalProgress} words`)
                            )
                        )
                    ),

                    // Weekly Progress
                    React.createElement('div', { className: "bg-white/10 backdrop-blur-lg rounded-xl p-4 border border-white/20 mb-6" },
                        React.createElement('div', { className: "flex justify-between items-center mb-4" },
                            React.createElement('h4', { className: "font-semibold" }, "Weekly Progress"),
                            React.createElement('span', { className: "text-sm" }, `Week ${currentWeek + 1}`)
                        ),
                        React.createElement('div', { className: "grid grid-cols-7 gap-1 mb-4" },
                            Array.from({ length: 7 }, (_, i) =>
                                React.createElement('div', {
                                    key: i,
                                    className: `h-8 rounded flex items-center justify-center text-xs font-semibold transition-colors ${
                                        i <= currentExample
                                            ? 'bg-green-500 text-white' 
                                            : 'bg-white/20 text-gray-300'
                                    }`
                                }, i + 1)
                            )
                        ),
                        React.createElement('div', { className: "text-sm text-blue-200 text-center" },
                            currentWord.isReview 
                                ? "🔄 Reviewing a starred word from your favorites"
                                : `Day ${currentExample + 1} of Week ${currentWeek + 1} • ${currentExample >= 6 ? 'New word at midnight!' : `${6 - currentExample} days until new word`}`
                        )
                    ),

                    // Spaced Repetition Info
                    favoriteWords.length > 0 && React.createElement('div', { className: "bg-white/10 backdrop-blur-lg rounded-xl p-4 border border-white/20 mb-6" },
                        React.createElement('h4', { className: "font-semibold mb-3 flex items-center gap-2" },
                            React.createElement(Star, { size: 16, filled: true }),
                            "Spaced Repetition Schedule"
                        ),
                        React.createElement('div', { className: "text-sm text-blue-200 mb-3" },
                            "Starred words will reappear for review every 4-6 weeks to strengthen retention."
                        ),
                        favoriteWords.length > 0 && React.createElement('div', { className: "space-y-2" },
                            React.createElement('p', { className: "font-semibold text-yellow-300" }, "Your Starred Words:"),
                            React.createElement('div', { className: "flex flex-wrap gap-2" },
                                favoriteWords.map(word => {
                                    const reviewDate = favoriteReviews[word] ? new Date(favoriteReviews[word]) : null;
                                    const isToday = reviewDate && reviewDate.toDateString() === new Date().toDateString();
                                    const daysUntilReview = reviewDate ? Math.ceil((reviewDate - new Date()) / (1000 * 60 * 60 * 24)) : null;
                                    
                                    return React.createElement('div', {
                                        key: word,
                                        className: `px-3 py-1 rounded-full text-xs ${
                                            isToday ? 'bg-yellow-500 text-black font-bold' : 'bg-purple-600 text-white'
                                        }`
                                    }, 
                                        word + (
                                            isToday ? ' (Today!)' : 
                                            daysUntilReview > 0 ? ` (${daysUntilReview}d)` : 
                                            daysUntilReview < 0 ? ' (Overdue)' : ''
                                        )
                                    );
                                })
                            )
                        )
                    ),

                    // Footer
                    React.createElement('div', { className: "text-center text-sm text-blue-200" },
                        React.createElement('p', null, "🔊 Click the volume button to hear pronunciation • ⭐ Star your favorite words"),
                        React.createElement('p', { className: "mt-2" }, 
                            `📚 ${vocabularyDatabase.length} words loaded • Updates automatically at midnight • 🔄 Starred words reviewed every 4-6 weeks`
                        )
                    )
                )
            );
        };

        ReactDOM.render(React.createElement(VocabularyBuilder), document.getElementById('root'));
    </script>
</body>
</html>
